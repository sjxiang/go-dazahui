

微服务框架 - 不变的基建


# 1 - 微服务架构介绍

    微服务架构的背景由来、架构概览、基本要素


# 2 - 微服务架构原理及特征

    微服务架构的基本组件、工作原理、流量特征


# 3- 核心服务治理功能

    核心的服务治理功能，包括流量治理、服务均衡、稳定性治理







# 1 - 微服务架构介绍


系统架构的演变历史

    为什么系统架构需要演进？
        
        - 互联网的爆炸性发展
        - 硬件设施的快速发展
        - 需求复杂性的多样化
        - 开发人员的急剧增加
        - 计算机理论及技术的发展

        - （跟风、KPI、找工作简历要填充）


 

    --------------------------------------------->
    
    单体架构
        垂直应用架构
            分布式架构
                SOA 架构
                    微服务架构




微服务架构
    优势
        1. 开发效率
        2. 业务独立设计 
        3. 自下而上（利用基础架构）
        4. 故障隔离
    
    劣势
        治理、运维难度


# 微服务架构原理及特征



微服务架构介绍
    系统架构的演进历史


    单体架构
        All in one process

    垂直应用架构
        按照业务线垂直划分

    分布式架构
        抽出与业务无关的公共模块

    SOA架构
        面向服务

    微服务架构
        彻底的服务化



# 微服务架构概览

    网关
    服务配置和治理
    链路追踪和监控


# 微服务架构的三大要素


    服务治理

        服务注册
            etcd

        服务发现

        负载均衡

        扩缩容
        流量治理

        稳定性治理
                限流
                熔断
                过载保护
                降级

        ...


    可观测性

        日志采集
        日志分析
        监控打点
        监控大盘
        异常报警
        链路追踪
        ...


    安全

        身份验证
        认证授权
        访问令牌
        审计
        传输加密
        黑产攻击
        ...



# 微服务架构原理及特征

微服务架构中的基本概念及组件


    服务
        一组具有相同逻辑的运行实体

    实例
        一个服务中，每个运行实体即为一个实例

    实例与进程的关系
        没有必然对应关系，一般一对一或者一对多

    集群    
        通常指服务内部的逻辑划分，包含多个实例

    常见的实例承载形式
        进程、VM、k8s pod......

    有状态 / 无状态服务
        服务的实例是否存储了可持久化的数据（例如磁盘文件）

    服务间通信
        对于单体服务，不同模块通信只是简单的函数调用。
        对于微服务，服务间通信意味着网络传输
    
   

服务注册及服务发现

    问题
        在代码层面，如何指定一个目标服务的地址（ip:port）？

            client := grpc.NewClient("127.0.0.1:8080")
    

    简单方案
        
        直接指定 ip:port？

            没有任何动态能力
            有多个实例下游实例怎么办？



        使用 DNS？

            本地 DNS 存在缓存，导致延迟
            DNS 没有负载均衡
            不支持服务实例的探活检查
            DNS 不能指定端口


    解决思路

        新增一个统一的服务注册中心，用于存储服务名到服务实例之间的映射关系
        旧服务实例下线前，从服务注册中心删除该实例，下线流量
        新服务实例上线后，在服务注册中心注册该实例，上线流量






微服务流量特征

    统一网关入口
    外网通信多数采用 HTTP，内网通信多数采用 RPC（Thrift, gRPC）




# 核心服务治理功能


服务发布（就是部署 / 何为服务发布，让一个服务升级运行新的代码的过程）


    服务发布难点

        服务不可用（中断一会儿，在线服务）
        服务抖动
        服务回滚（有 BUG ）


    蓝绿部署（流量慢慢切过去）

        将服务分成两个部分，分别先后发布
        简单、稳定，但需要两倍资源



    灰度发布（金丝雀发布）

        先发布少部分实例，接着逐步增加发布比例（旧 + 新 = 1）
        不需要增加资源
        回滚难度大，基础设施要求高



流量治理（流量控制）

    在微服务架构中，可以从各个维度对端到端的流量在链路上进行精确控制


    控制维度
        地区维度
        集群维度
        实例维度
        请求维度


负载均衡（负责分配请求在每个下游实例上的分布）

    常见策略
        Round Robin 轮询
        Random
        Ring Hash 一致性哈希
        Least Request


稳定性治理
    线上服务总是会出问题，这与程序的正确性无关

    客观因素
        光线被挖断、机房停电 ...



    限流
        限制服务处理的最大 QPS，拒绝过多请求（服务器上限 1k，结果来了 5k）

    熔断
        中断请求路径，增加冷却时间从而让故障实例尝试恢复（服务器异常）

    过载保护
        在负载高的实例中，主动拒绝一部分请求，防止实例被打挂（服务器 CPU 飙到 99%，要缓缓）

    降级
        服务处理能力不足时，拒绝低级别的请求，只响应线上高优请求







# 请求重试的意义


    - 本地函数调用

        参数非法、OOM、空指针、边界 case、系统崩溃、死循环、程序异常退出

        通常没有重试意义


    - 远程函数调用

        网络抖动、下游负载高、下游机器宕机 ......

        重试是有意义的，可以避免偶发性的错误，提高 SLA


请求重试的难点

    幂等性
        POST 请求可以重试吗？

    重试风暴
        随着调用链路的增加，重试次数呈指数级上升

    超时设置
        假设调用时间一共1s，经过多少时间开始重试？








重试策略


    限制重试比例
        设定一个重试比例阈值（例如 1%），重试次数占所有请求比例不超过该阈值

    防止链路重试
        返回特殊的 status code，表示“请求失败，但别重试”

    Hedged Requests
        对于可能超时（或延时高）的请求，重新向另一个下游实例发送一个相同的请求，并等待先到达的响应

