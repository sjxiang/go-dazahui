


分布式理论 
-- 现代架构基石


# Agenda

本节课程主要分为 6 个方面：

概述    
系统模型
理论基础
分布式事务
共识协议
分布式实践


=== 

概述

    - 什么是分布式？
    - Why-How-What
    - 常见的分布式系统


系统模型

    - 故障模型
    - 拜占庭将军问题
    - 共识和一致性
    - 时间和事件顺序


理论基础

    - CAP 理论
    - ACID 理论
    - BASE 理论


分布式事务

    - 两阶段提交
    - 三阶段提交
    - MVCC


共识协议

    - Quorum NWR 模型
    - Raft 协议
    - Paxos 协议


分布式实践

    - MapReduce
    - 分布式 KV



===

# 1 - 概述

## 1.1 什么是分布式？

    分布式系统定义：跨多个节点的计算机程序的集合


优势：
    1. 去中心化（跑在集群上）
    2. 低成本（红米千元机，耐糙、便宜）
    3. 弹性（峰谷、扩容）
    4. 资源共享（单个服务使用资源是有限的，用不了，匀点给出来）
    5. 可靠性高（多副本、冗余）


挑战：
    1. 普遍的节点故障
    2. 不可靠的网络（33 种状态：对、错、未决）
    3. 异构的机器与硬件环境（不同环境，性能差异蛮大的）
    4. 安全



## 1.2 Why-How-What

使用者视角：大规模计算存储的述求
    Why:
        1. 数据爆炸，对存储和计算有大规模运用的诉求
        2. 成本低，构建在廉价服务器上

    How:
        1. 分布式框架
        2. 成熟的分布式系统

    What:
        1. 理清规模、负载、一致性要求等
        2. 明确稳定性要求，制定技术方案



学习者视角：后端开发必备技能
    Why:
        1. 后端开发必备技能
        2. 帮助理解后台服务器之间协作的机理

    How:
        1. 掌握分布式理论
        2. 了解一致性协议

    What:
        1. 把要点深入展开，针对难点，搜索互联网资料进行学习
        2. 将所学知识用于实践



## 1.3 常见的分布式系统

    分布式存储：GFS、Ceph、HDFS、Zookeeper
    分布式数据库：Spanner、TiDB、HBase、MangoDB
    分布式计算：Hadoop、YARN、Spark



# 2 - 系统模型

## 2.1 故障模型


六种故障模型，从处理的难易程度分类

    - Byzantine failure：节点可以任意篡改发送给其他节点的数据，是最难处理的故障
    - Authentication detectable byzantine failure (ADB)：节点可以篡改数据，但不能伪造其他节点的数据（特例）
    - Performance failure：节点未在特定时间段内收到数据，即时间太早或太晚（经验之谈：处理时快时慢，与其想着恢复正常，还不如赶紧挂掉，不纠结）
    - Omission failure：节点收到数据的时间无限晚，即收不到数据
    - Crash failure：节点停止响应，持续性的故障
    - Fail-stop failure：错误可检测，是最容易处理的故障


    4 个维度衡量 "正确性"、"时间"、"状态"、"原因"


    
故障模型举例，按照模型分类

    磁盘、主板、交换机、网络分区、cpu、内存、线缆、电源等故障详细说明



## 2.2 拜占庭将军问题

（不知道消息传递是真是假，大多数分布式系统都不解决拜占庭故障，不好处理；往往把传递的消息加密或冗余设计，确保消息篡改被识别）



两将军问题

    定义：
        两支军队的将军只能派信使穿越敌方领土互相通信，以此约定进攻时间。
        该问题希望求解如何在两名将军派出的任何信使都可能被俘虏的情况下，就进攻时间达成共识

    结论：
        两将军问题是被证实无解的电脑通信问题，两支军队理论上永远无法达成共识


    方案
        1 同时发送 N 个信使，任何一个到达对方军队，都算成功。（提高概率）
        2 设置超时时间，发送后未在一定时间返回，则加派信使。


    共识与消息传递的不同：
        即使保证了消息传递成功，也不能保证达成共识。


    TCP 是两将军问题的一个工程解（双方的序列号，重传）





三将军问题：

    两个“忠将”A和B，一个“叛徒”C，互相传递消息，消息可能丢失，也可能被篡改，当有一个将军是“叛徒”（即出现拜占庭故障）时，整个系统无法达成一致。

    由于“叛徒”C的存在，将军A和将军B获得不同的信息。这样将军A获得2票进攻1票撤退的信息，将军B获得1票进攻2票撤退的信息，产生了不一致



四将军问题：

    将军D作为消息分发中枢，约定如果没收到消息则执行撤退

    步骤：

        如果D为“叛徒”，ABC无论收到任何消息，总能达成一致
        D为“忠将”，ABC有2人将D的消息进行正确的传递，同样能保证最终决策符合大多数。



        进而能够证明，当有3m+1个将军，m个“叛徒”时，可以进行m轮协商，最终达成一致




## 2.3 共识和一致性

不同客户端 A 和 B 看到客户端 C 写入，因为时机的不同，产生数据读取的偏差。
引导出最终一致性的详细说明
要保证所有客户端看到相同的值，需要多节点进行“协商”，达成共识，来保证线性一致性
一致性和可用性是对矛盾


情况 1
    客户端 A 读到 x=0，当客户端 C 正在写入时，客户端 A 和 B 可能读到 0 或者 1。
    但当 C 写入完成后，A 和 B 最终读到一致的数据。
    我们称这样的一致性为 Eventually Consistent （最终一致性）


情况 2
    当客户端 A 读到更新的版本 x=1 后，及时将消息同步给其它客户端，这样其他客户端立即能获取到 x=1。
    我们称这样的一致性为 Linearizability（线性一致性）


如果要保证“线性一致性”，多个节点间势必需要进行协商（同步），以寻求一致。
这样增加了延迟，系统可用性便会受损。



## 2.4 时间和事件顺序


1978 年，Leslie Lamport 发表在 ACM 通讯上的论文
《Time, Clocks, and the Ordering of Events in a Distributed System》，奠基。


定义了计算机系统中的时间和事件顺序，引入 happened before 和并发的定义，可以以此对分布式系统中的事件进行推导。
根据上述推导，创造了 Lamport 逻辑时钟的概念，这个概念在分布式理论中具有革命性的意义，帮助我们在一系列分布式事件当中梳理出逻辑的先后关系。利用逻辑时钟，我们可以对整个系统中的事件进行全序排序





逻辑时钟
    离散





# 3 - 理论基础


## 3.1 CAP 理论


CAP 的定义，分别代表一致性、可用性、分区容错性。三者无法同时达到

    选项 描述


CAP 诞生了三类系统：

    CA 系统：传统数据库的代表
    AP 系统：放弃强一致性，保证高可用，不少nosql存储系统采用
    CP 系统：放弃可用性，保证数据一致性



举例说明两个分布式进程之间同步数据，当出现故障的时候，如何选择不同的 CAP 系统，以及带来的影响

    CP 系统：故障发生时，为了避免读到不一致的数据，可能拒绝访问
    AP 系统：故障发生时，为了保证可用性，允许不同进程读到不同的数据


在网络发生分区的情况下，我们必须在可用性和一致性之间做出选择。

近似解决办法：把故障节点的负载转移给备用节点负责。

    针对故障场景，可以通过故障转移的方式，做一个相对较优的解决方式：

    允许一个进程作为 Master，其他进程作为 Backup，当故障时将请求转移给 Backup 进行处理



## 3.2 ACID 理论

ACID 理论是针对 CA 系统而言的，通常在数据库中具有广泛意义

事务是数据库系统中非常重要的概念，它是数据库管理系统执行过程中的一个逻辑单元，它能够保证一个事务中的所有操作要么全部执行，要么全都不执行
数据库事务拥有四个特性ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）

e.g. 转账

两个操作捆绑在一块
事务一致性，账务综合一致


原子性
一致性
隔离性
持久性

隔离性不能保证，MySQL

## 3.3 BASE 理论


BASE 理论是针对 AP 系统而言的，其来源于对大型互联网分布式实践的总结

Basically Available(基本可用)：假设系统，出现了不可预知的故障，但还是能用
Soft state（软状态）：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性
Eventually consistent（最终一致性）：数据最终一定能够达到一致的状态



# 4 - 分布式事务

（不同节点发生转账）

## 4.1 二阶段提交


定义：
    二阶段提交（Two-phase Commit）：为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种演算法。



三个假设：

    1. 引入协调者（Coordinator）和参与者（Participants），互相进行网络通信
    2. 所有节点都采用预写式日志，且日志被写入后，即被保持在可靠的存储设备上
    3. 所有节点不会永久性损坏，即使损坏后仍然可以恢复



正常流程：Prepare 阶段和 Commit 阶段
    C - Prepare -> P1
    C <- Done -  P1

    C - Commit -> P1
    C <- ACK -  P1


异常流程：Prepare 阶段失败 -> 回滚；协调者宕机 -> 重新启用新的协调者；双故障重启 -> 数据库管理员介入
    可能出现的情况
    情况 3：未决


两阶段提交需解决的问题：

1. 性能问题：需要多次网络通信，资源需要等待并锁定
2. 新协调者：如何确定状态选出新协调者
3. Commit 阶段网络分区带来的数据不一致：非所有节点都收到Commit请求

    回滚加锁，但会阻塞


两个思考：

日志被保存在「可靠」的存储设备上。如何保证这一点？
    分布式 kv 

参与者 Commit 了，但 Ack 信息协调者没收到。怎么办？
    回滚，有点浪费


## 4.2 三阶段提交

针对两阶段提交的补充，将两阶段提交中的 Prepare 阶段，拆成两部分：CanCommit 和 PreCommit 机制

准备 2 w，发现账上只有 3 k。


    CanCommit 阶段：询问是否可以执行；
    
    PreCommit 阶段：重新确认是否可以执行 可以
    
    DoCommit 阶段：向所有人提交事务



没啥区别，就是一些优化


## 4.3 MVCC


MVCC：多版本并发控制的方法。维持一个数据的多个版本使读写操作没有冲突。所以既不会阻塞写，也不阻塞读。提高并发性能的同时也解决了脏读的问题。


悲观锁和乐观锁

悲观锁：操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据
乐观锁：不会上锁，只是在执行更新时判断别人是否修改数据，只有冲突时才放弃操作

乐观锁遇到冲突，麻烦了，看场景


实现 蓝波顿时钟
版本的选取：使用物理时钟或逻辑时钟

物理时钟：提供 TrueTime API，有 Master节点维持一个绝对时间，保证各个服务器之间时钟误差控制在ϵ内，通常ϵ<7ms。
（依赖硬件）

逻辑时钟：中心化授时的方式--时间戳预言机（TSO），好处是无需硬件的支持
4 次



# 5 - 共识协议

## 5.1 Quorum NWR 模型


三要素：

N：在分布式存储系统中，有多少份备份数据
W：代表一次成功的更新操作要求至少有 w 份数据写入成功
R：代表一次成功的读数据操作要求至少有 R 份数据成功读取

为了保证强一致性，需要保证 W+R>N



Quorum NWR 模型将 CAP 的选择交给用户，是一种简化版的一致性模型（精髓，自由）


引起的并发更新问题

如果允许数据被覆盖，则并发更新容易引起一致性问题
（追加写日志，数据就不会被覆盖）


## 5.2 RAFT 协议


概述

RAFT 协议是一种分布式一致性算法（共识算法），即使出现部分节点故障，网络延时等情况，也不影响各节点，进而提高系统的整体可用性。RAFT 是使用较为广泛的分布式协议。



三种角色

Leader - 领导者：Leader 负责处理所有的客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后，通知Follower提交日志
Follower - 跟随者：接受并持久化Leader同步的日志，在Leader告知日志可以提交后，提交日志
Candidate - 备选者：Leader选举过程中的临时角色。向其他节点发送请求投票信息


状态机


四种定义：

Log（日志）：节点之间同步的信息，以只追加写的方式进行同步，解决了数据被覆盖的问题
Term（任期号）：单调递增，每个Term内最多只有一个Leader
Committed：日志被复制到多数派节点，即可认为已经被提交
Applied：日志被应用到本地状态机：执行了log中命令，修改了内存状态



状态转移：
Leader选举过程：
初始全部为Follower
Current Term + 1
选举自己
向其它参与者发起RequestVote请求，retry直到
收到多数派请求，成为Leader，并发送心跳
收到其它Leader的请求，转为Follower，更新自己的Term
收到部分，但未达到多数派，选举超时，随机timeout开始下一轮





Log Replication过程：

新Leader产生，Leader和Follower不同步，Leader强制覆盖Followers的不同步的日志



切主：当Leader出现问题时，就需要进行重新选举

Leader发现失去Follower的响应，失去Leader身份
两个Follower之间一段时间未收到心跳，重新进行选举，选出新的Leader，此时发生了切主
Leader自杀重启，以Follower的身份加入进来



Stale读：

发生Leader切换，old leader收到了读请求。如果直接响应，可能会有Stale Read

（类似两阶段提交，都是 leader 主导，要是有问题，怎么切换）

stale 读
过期的意思




## 5.3 Paxos 协议


Paxos算法与RAFT算法区别：

Multi-Paxos 可以并发修改日志，而Raft写日志操作必须是连续的
Multi-Paxos 可以随机选主，不必最新最全的节点当选Leader



优劣势

优势：写入并发性能高，所有节点都能写
劣势：没有一个节点有完整的最新的数据，恢复流程复杂，需要同步历史记录





# 6 - 分布式实践


## 6.1 MapReduce

设计一个简易的MapReduce系统，思考如何应对故障？


## 6.2 分布式 KV

设计一个简易的分布式键值系统，要求具备弹性的能力和达成线性一致




课后


分布式系统有哪些优势和挑战？

两将军问题为什么理论上永远达不成共识？

为什么TCP采用三次握手？而不是两次和四次？

为什么在4将军问题中，增加1轮协商就可以对抗拜占庭故障？

什么是最终一致性？什么是线性一致性？

CAP理论中，请举例说明可用性和一致性的矛盾？

数据库里的一致性和分布式系统中的一致性有什么区别？

两阶段提交中，什么场景需要数据库管理员介入？

三阶段提交缓和两阶段提交的哪两个问题？

什么场景适合乐观锁？什么场景适合悲观锁？

在共识协议中，为什么说允许数据被覆盖会带来数据一致性问题？

RAFT协议中，Leader写成功日志Log20但未同步给Followers后宕机，Follower重新选举后产生一条新日志Log20，这时Leader重启，整个系统发现两种不一样的Log20的记录，请问如何区分并拒掉前面的Log20？

RAFT协议中，Stale读是如何产生的？该如何解决Stale读的问题？

